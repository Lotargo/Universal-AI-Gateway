import re
import logging
import json
from typing import Dict, Optional, Any
from bs4 import BeautifulSoup

logger = logging.getLogger("UniversalAIGateway")

class FuzzyXmlParser:
    """
    A robust parser using BeautifulSoup to handle malformed, unclosed, or messy XML/HTML
    generated by Instruct models (like Groq/Mistral).
    """

    @staticmethod
    def _is_likely_action(text: str) -> bool:
        if not text:
            return False
        t = text.strip()
        if t.startswith("{") or t.startswith("["):
            return True
        if t.startswith(">>>"):
            return True
        if t.startswith("```"):
            return True
        return False

    @staticmethod
    def parse(text: str) -> Dict[str, Any]:
        """
        Parses text for <THOUGHT>, <ACTION>, <FINAL_ANSWER>, <think>, <DRAFT> tags.
        Returns a dictionary with extracted content and metadata.
        """
        if not text:
            return {"thought": None, "thought_attrs": {}, "action": None, "final_answer": None, "draft": None}

        soup = BeautifulSoup(text, "html.parser")

        result = {"thought": None, "thought_attrs": {}, "action": None, "final_answer": None, "draft": None}

        def get_tag_info(tag_name: str) -> (Optional[str], Dict[str, str]):
            tags = soup.find_all(tag_name.lower())
            if not tags:
                return None, {}
            # Use the last tag found
            tag = tags[-1]
            content = tag.get_text(separator="\n", strip=True)
            return (content if content else None), tag.attrs

        # 1. Thought
        thought_content, thought_attrs = get_tag_info("thought")
        if not thought_content:
            thought_content, thought_attrs = get_tag_info("think")

        result["thought"] = thought_content
        result["thought_attrs"] = thought_attrs

        # 2. Action
        action_candidate, _ = get_tag_info("action")
        if action_candidate and FuzzyXmlParser._is_likely_action(action_candidate):
            result["action"] = action_candidate
        else:
            result["action"] = None

        # 3. Final Answer
        result["final_answer"], _ = get_tag_info("final_answer")

        # 4. Draft
        result["draft"], _ = get_tag_info("draft")

        return result

    @staticmethod
    def extract_from_failed_generation(error_text: str) -> Dict[str, Any]:
        if not error_text:
            return {"thought": None, "thought_attrs": {}, "action": None, "final_answer": None, "draft": None}

        content_candidate = None

        # Strategy 1
        json_match = re.search(r"Details:\s*({.*})", error_text, re.DOTALL)
        if json_match:
            try:
                data = json.loads(json_match.group(1))
                if "failed_generation" in data:
                    content_candidate = data["failed_generation"]
            except:
                pass

        # Strategy 2
        if not content_candidate:
            match = re.search(r'"failed_generation"\s*:\s*"(.*?)(?<!\\)"', error_text, re.DOTALL)
            if match:
                content_candidate = match.group(1)
                try:
                    content_candidate = json.loads(f'"{content_candidate}"')
                except:
                    pass

        target_text = content_candidate if content_candidate else error_text
        res = FuzzyXmlParser.parse(target_text)

        # Fallback Logic
        if not res["thought"] and not res["action"] and not res["final_answer"] and not res["draft"]:
            if content_candidate and len(content_candidate.strip()) > 10:
                res["thought"] = content_candidate.strip()
        else:
            extracted_len = len(res["thought"] or "") + len(res["action"] or "") + len(res["final_answer"] or "") + len(res["draft"] or "")
            total_len = len(target_text)

            clean_target = target_text.strip()
            is_structured = clean_target.startswith("{") or clean_target.startswith("<")

            if (extracted_len < total_len * 0.6) and not res["action"] and not res["final_answer"] and not res["draft"] and not is_structured:
                res["thought"] = target_text

        return res
